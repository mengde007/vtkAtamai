from __future__ import print_function
# =========================================================================
#
#   Program:   Atamai Surgical Planning
#   Module:    $RCSfile: EventHandler.py,v $
#   Language:  Python
#   Date:      $Date: 2006/06/06 16:59:29 $
#   Version:   $Revision: 1.2 $
#
#
# Copyright (c) 2000 Atamai, Inc.
#
# Use, modification and redistribution of the software, in source or
# binary forms, are permitted provided that the following terms and
# conditions are met:
#
# 1) Redistribution of the source code, in verbatim or modified
#    form, must retain the above copyright notice, this license,
#    the following disclaimer, and any notices that refer to this
#    license and/or the following disclaimer.
#
# 2) Redistribution in binary form must include the above copyright
#    notice, a copy of this license and the following disclaimer
#    in the documentation or with other materials provided with the
#    distribution.
#
# 3) Modified copies of the source code must be clearly marked as such,
#    and must not be misrepresented as verbatim copies of the source code.
#
# THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE "AS IS"
# WITHOUT EXPRESSED OR IMPLIED WARRANTY INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE.  IN NO EVENT SHALL ANY COPYRIGHT HOLDER OR OTHER PARTY WHO MAY
# MODIFY AND/OR REDISTRIBUTE THE SOFTWARE UNDER THE TERMS OF THIS LICENSE
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, LOSS OF DATA OR DATA BECOMING INACCURATE
# OR LOSS OF PROFIT OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF
# THE USE OR INABILITY TO USE THE SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGES.
#
# =========================================================================

#
# This file represents a derivative work by Parallax Innovations Inc.
#

from builtins import str
from builtins import object
__rcs_info__ = {
    #
    #  Creation Information
    #
    'module_name': '$RCSfile: EventHandler.py,v $',
    'creator': 'David Gobbi <dgobbi@atamai.com>',
    'project': 'Atamai Surgical Planning',
    #
    #  Current Information
    #
    'author': '$Author: jeremy_gill $',
    'version': '$Revision: 1.2 $',
    'date': '$Date: 2006/06/06 16:59:29 $',
}
try:
    __version__ = __rcs_info__['version'].split(' ')[1]
except:
    __version__ = '0.0'

"""
EventHandler - bind events to callback functions

  The EventHandler is the base class for most of the other classes.
  The purpose of this class is to bind callback functions to GUI
  events (mouse movements and keystrokes) that are generated by the
  user.

  The EventHandler has two methods: BindEvent() and HandleEvent().
  The BindEvent method is used to binds callback functions to events
  via Tk-style event descriptors.
  The HandleEvent method accepts Tkinter-style event objects and passes
  the event off to the appropriate callback.

  Events are typically created in a PaneFrame object (which represents
  a "Window" or more specifically a rendering context), passed to
  a RenderPane (which represents a virtual scene), and possibly passed
  to an ActorFactory (which represents a 3D object within the scene).

Derived From:

  none

See Also:

  ActorFactory, RenderPane, PaneFrame

Initialization:

  EventHandler()

Public Methods:

  BindEvent(*descriptor*,*method*)
                     -- bind an event to a method via a Tk-style
                        event descriptor

  HandleEvent(*event*)
                     -- send an event through the event handler, which
                        causes any bound methods to be called

  PrintEvent(*event*)
                     -- mainly for debug purposes: print an event object

  SetDoubleClickInterval(*interval*)
                     -- set the interval for double-click events, in seconds
                        (the default is 0.2 seconds)

Class Attributes:

  EventModifier      -- dictionary to convert modifier descriptors,
                        e.g. "Shift", into modifier bits

  EventType          -- dictionary to convert event descriptors,
                        e.g. "Motion", into Tkinter-style event
                        type constants


Event Binding:

  An event descriptor is always of the form

  "<" [modifier "-"]* type ["-" ( button | keysym ) ">"

  Simple examples are "<ButtonPress-1>" for a left-mouse-button press,
  or "<Control-KeyRelease-g>" for when the "g" is released while the
  "Control" key is being held down.

  The full list of common modifiers is 'Shift', 'Control', 'B1', 'B2',
  'B3', and 'Double' where the 'Double' modifier is only relevant for
  ButtonPress events.

  The full list of event types is 'KeyPress', 'KeyRelease', 'ButtonPress',
  'ButtonRelease', 'Motion' (mouse motion), 'Enter', 'Leave', 'FocusIn',
  'FocusOut', and 'Configure'.

  The available keysym key descriptors are derived from the header file
  X11/keysymdef.h, and are of the form 'g', 'G', 'equal', 'plus', 'Return',
  'Up', 'Shift_L', etcetera.  The rule is that the names of special keys
  are always capitalized, and if the key appears on both sides of the
  keyboard then the name must be followed by '_L' or '_R'.

  To bind a left-doubleclick with a handler function, you would use::

    eventHandler.BindEvent("<Double-ButtonPress-1>", DoStuff)

  Where the function "DoStuff" is declared as follows::

    def DoStuff(event):
        ...


Event Handling:

  The event-handler functions take the form DoStuff(*event*) where *event*
  is an object that contains attributes that are relevant to the event, e.g.:

   - event.type       - a string that is unique to the event type

   - event.state      - an int containing bits for modifier keys (for
                        key and mouse events only)

   - event.keysym     - the keysym (key events only)

   - event.char       - the ASCII key code (key events only)

   - event.num        - the mouse button number (press/release events only)

   - event.x, event.y - mouse coordinates relative to the lower-left
                        corner of window (VTK display coordinates) for
                        key and mouse events, or window position for
                        Configure events

   - event.width, event.height
                      - window width and height for configure events

  The event handler function should return None if the event was handled
  successfully, or '1' if the event was ignored.


Bugs, Missing Features:

  - Only one callback can be bound to a particular event at any point
    in time.  It would be nice to have a "BindEventNonExclusive" method
    that will allow multiple callbacks to be bound.

  - The event.type is a numbers, in keeping with the Tk event types.
    This makes the code a little harder to understand, so a switch to
    textual event.type attribute ("Motion" instead of "6") should be
    done.

  - Alternatively, constants could be introduced e.g. ET_Motion = "6"
    but this would be less efficient than using string literals.

"""

#======================================
import time
import sys

# this is an ugly little hack to switch NumLock and Alt bits for Windows
import sys
if (sys.platform == 'win32'):
    NUMLOCKBIT = 8
    ALTBIT = 16
else:  # UNIX
    NUMLOCKBIT = 16
    ALTBIT = 8

#======================================


class Event(object):

    """The event class is just a container for attributes."""

    def __init__(self, event=None):
        """Construct an event object.

        If an event is passed to the constructer, then all the attributes
        will be copied from that event to the new event.

        """
        if event is not None:
            for key, val in list(event.__dict__.items()):
                setattr(self, key, val)

#======================================


class EventHandler(object):

    """The EventHandler dispatches GUI events to callback functions."""

    # Dictionary to convert a modifier description to a modifier bit.
    EventModifier = {
        "Shift": 1,
        "CapsLock": 2,
        "Control": 4,
        "Alt": ALTBIT,
        "NumLock": NUMLOCKBIT,
        "Meta": 32,
        "ScrollLock": 128,
        "Mod1": 8,
        "Mod2": 16,
        "Mod3": 32,
        "Mod4": 64,
        "Mod5": 128,
        "M1": 8,
        "M2": 16,
        "M3": 32,
        "M4": 64,
        "M5": 128,
        "Button1": 256,
        "Button2": 512,
        "Button3": 1024,
        "Button4": 2048,
        "Button5": 4096,
        "B1": 256,
        "B2": 512,
        "B3": 1024,
        "B4": 2048,
        "B5": 4096,
        "Double": 8192,
    }

    # Dictionary to convert an event type descriptor to a byte.
    if  sys.version_info.major == 2:
        _func = intern
    else:
        _func = sys.intern
    EventType = {
        "KeyPress": _func('2'),
        "Key": _func('2'),
        "KeyRelease": _func('3'),
        "ButtonPress": _func('4'),
        "Button": _func('4'),
        "ButtonRelease": _func('5'),
        "Motion": _func('6'),
        "Enter": _func('7'),
        "Leave": _func('8'),
        "FocusIn": _func('9'),
        "FocusOut": _func('10'),
        "Configure": _func('22'),
    }

    def __init__(self):
        """Create an EventHandler with no bindings."""

        # Dictionary which binds events to methods.
        self.RemoveAllEventHandlers()

    def RemoveAllEventHandlers(self):
        self.__EventDict = {}

    #-------------------------------------------------------------------
    def BindEvent(self, eventDescriptor, func):
        """Bind a callback function to an event descriptor.

        Parameters:

        *eventDescriptor* - a Tk-style event descriptor

        *func* - a callback function, or None if you want to
                 unbind an event

        Result:

        The previously bound function, or None.

        The callback should accept one parameter, an event object.
        The event descriptor should follow the Tk syntax for event
        descriptors.

        """
        if (eventDescriptor[0] != '<' or eventDescriptor[-1] != '>'):
            raise ValueError("malformed event discriptor " + eventDescriptor)

        # parse the event descriptor
        field = eventDescriptor[1:-1].split('-')

        # find all modifiers
        modifier = 0
        while 1:
            try:
                modifier = modifier | self.EventModifier[field[0]]
                del field[0]
            except KeyError:
                break

        # find the event type
        try:
            type = self.EventType[field[0]]
            del field[0]
        except KeyError:
            type = '2'

        # find the keysym/button
        keysym = None
        try:
            keysym = field[0]
            # need to modify keysym if shift or caps
            if ((type in ('2', '3')) and (modifier & 3) and (len(keysym) == 1)):
                keysym = keysym.upper()

            del field[0]
        except:
            keysym = None

        if (len(field) != 0):
            raise ValueError("malformed event discriptor " + eventDescriptor)

        # check to see if event is already bound, and make an
        # entry if it isn't
        try:
            eventList = self.__EventDict[type]
        except KeyError:
            eventList = self.__EventDict[type] = [0, {}, {}]

        # if there is a keysym/button, go to sub-dict
        # (make the sub-dict if it doesn't exist)
        if keysym:
            try:
                keysymList = eventList[2][keysym]
            except KeyError:
                keysymList = eventList[2][keysym] = [0, {}]
            eventList = keysymList

        # grab the function that was previously bound
        try:
            oldfunc = eventList[1][modifier]
        except:
            oldfunc = None

        if func:
            # specify which modifiers have specific handlers,
            # and bind the function to the modifier
            eventList[0] = eventList[0] | modifier
            eventList[1][modifier] = func
        else:
            # func is None: delete the key, rebuild modifier flags
            if modifier in eventList[1]:
                del eventList[1][modifier]
                eventList[0] = 0
                for key in list(eventList[1].keys()):
                    eventList[0] = eventList[0] | key

        return oldfunc

    #-------------------------------------------------------------------
    def HandleEvent(self, event):
        """Dispatch an event to the appropriate callback.

        Parameters:

        *event* - a valid event object

        Result:

        None if the event was handled, or 1 if there was no callback
        bound to the event or if the callback did not handle the event.

        The bindings are prioritized according to specificity.  For
        example, if a "<Control-ButtonPress-1>" event is sent to the
        handler then the handler will first look for a
        "<Control-ButtonPress-1>" callback, then for a
        "<ButtonPress-1>" callback, and finally for a "<ButtonPress>"
        callback.  Only the callback with the most specific binding
        will be called.

        """
        # dispatch events to the handlers
        type = event.type
        try:
            modifier = event.state
        except AttributeError:
            modifier = 0
        keysym = '0'
        if int(type) <= 3:    # if key event
            keysym = event.keysym
        elif int(type) <= 5:  # if mouse press event
            keysym = str(event.num)

        # search for the event (this is pretty quick)
        try:
            eventList = self.__EventDict[type]
            try:  # see if there is a keysym/button specific binding
                keysymList = eventList[2][keysym]
                func = keysymList[1][keysymList[0] & modifier]
            except KeyError:
                func = eventList[1][eventList[0] & modifier]

        except KeyError:  # event not bound
            return 1

        # call the handler function!
        return func(event)

    #-------------------------------------------------------------------
    def PrintEvent(self, event):
        """A diagnostic method that prints all event attributes."""

        # type
        d = self.EventType
        print(('%-13s ' % list(d.keys())[list(d.values()).index(event.type)]), end=' ')

        # num
        try:
            print(('%3d    ' % (event.num % 1000,)), end=' ')
        except:
            print(' ??    ', end=' ')

        # char
        try:
            if event.char >= ' ' and event.char <= '~':
                print(('%1.1c     ' % event.char), end=' ')
            else:
                print(('\\%03.3o' % ord(event.char)), end=' ')
        except:
            print('?? ', end=' ')

        # sym
        try:
            print(('%-13s ' % (event.keysym,)), end=' ')
        except:
            print(('%-13s ' % ('??',)), end=' ')

        # position
        try:
            print(('(%4d,%4d)    ' % (event.x, event.y)), end=' ')
        except:
            print('(    ??,    ??)    ', end=' ')

        # state
        d = self.EventModifier
        s = event.state
        i = 1
        while s:
            if s & 0x1:
                print(list(d.keys())[list(d.values()).index(i)], end=' ')
            s = s >> 1
            i = i << 1

        # end the line
        print()
